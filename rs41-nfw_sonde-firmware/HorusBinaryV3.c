/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"

#include "HorusBinaryV3.h"

flag horusBitFlags_IsConstraintValid(const horusBitFlags* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void horusBitFlags_Initialize(horusBitFlags* pVal)
{
	(void)pVal;


	/*set b0 */
	pVal->b0 = FALSE;
	/*set b1 */
	pVal->b1 = FALSE;
	/*set b2 */
	pVal->b2 = FALSE;
	/*set b3 */
	pVal->b3 = FALSE;
	/*set b4 */
	pVal->b4 = FALSE;
	/*set b5 */
	pVal->b5 = FALSE;
	/*set b6 */
	pVal->b6 = FALSE;
	/*set b7 */
	pVal->b7 = FALSE;
}

flag horusBitFlags_Encode(const horusBitFlags* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? horusBitFlags_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode b0 */
	    BitStream_AppendBit(pBitStrm,pVal->b0);
	    if (ret) {
	        /*Encode b1 */
	        BitStream_AppendBit(pBitStrm,pVal->b1);
	        if (ret) {
	            /*Encode b2 */
	            BitStream_AppendBit(pBitStrm,pVal->b2);
	            if (ret) {
	                /*Encode b3 */
	                BitStream_AppendBit(pBitStrm,pVal->b3);
	                if (ret) {
	                    /*Encode b4 */
	                    BitStream_AppendBit(pBitStrm,pVal->b4);
	                    if (ret) {
	                        /*Encode b5 */
	                        BitStream_AppendBit(pBitStrm,pVal->b5);
	                        if (ret) {
	                            /*Encode b6 */
	                            BitStream_AppendBit(pBitStrm,pVal->b6);
	                            if (ret) {
	                                /*Encode b7 */
	                                BitStream_AppendBit(pBitStrm,pVal->b7);
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag horusBitFlags_Decode(horusBitFlags* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode b0 */
	ret = BitStream_ReadBit(pBitStrm, (&(pVal->b0)));
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BITFLAGS_B0;
	if (ret) {
	    /*Decode b1 */
	    ret = BitStream_ReadBit(pBitStrm, (&(pVal->b1)));
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BITFLAGS_B1;
	    if (ret) {
	        /*Decode b2 */
	        ret = BitStream_ReadBit(pBitStrm, (&(pVal->b2)));
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BITFLAGS_B2;
	        if (ret) {
	            /*Decode b3 */
	            ret = BitStream_ReadBit(pBitStrm, (&(pVal->b3)));
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BITFLAGS_B3;
	            if (ret) {
	                /*Decode b4 */
	                ret = BitStream_ReadBit(pBitStrm, (&(pVal->b4)));
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BITFLAGS_B4;
	                if (ret) {
	                    /*Decode b5 */
	                    ret = BitStream_ReadBit(pBitStrm, (&(pVal->b5)));
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BITFLAGS_B5;
	                    if (ret) {
	                        /*Decode b6 */
	                        ret = BitStream_ReadBit(pBitStrm, (&(pVal->b6)));
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BITFLAGS_B6;
	                        if (ret) {
	                            /*Decode b7 */
	                            ret = BitStream_ReadBit(pBitStrm, (&(pVal->b7)));
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BITFLAGS_B7;
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && horusBitFlags_IsConstraintValid(pVal, pErrCode);
}


flag CustomFieldValues_horusStr_CharsAreValid_0(const char* str)
{
    flag ret=TRUE;
    int i=0;

    while ((str[i] != '\0') && ret) {
        ret = ret && (strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_ +/=-.", str[i]));
        i = i + 1;
    }
    return ret;
}
flag horusCustomFieldValues_horusStr_IsConstraintValid(const horusCustomFieldValues_horusStr pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (CustomFieldValues_horusStr_CharsAreValid_0(pVal) && (strlen(pVal) <= 255));
    *pErrCode = ret ? 0 :  ERR_CUSTOMFIELDVALUES_HORUSSTR;

	return ret;
}

flag horusCustomFieldValues_horusInt_IsConstraintValid(const horusCustomFieldValues_horusInt* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_CUSTOMFIELDVALUES_HORUSINT;

	return ret;
}

flag horusCustomFieldValues_horusReal_IsConstraintValid(const horusCustomFieldValues_horusReal* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_CUSTOMFIELDVALUES_HORUSREAL;

	return ret;
}

flag horusCustomFieldValues_IsConstraintValid(const horusCustomFieldValues* pVal, int* pErrCode)
{
    flag ret = TRUE;
    switch (pVal->kind) {
        case horusStr_PRESENT : 
            ret = horusCustomFieldValues_horusStr_IsConstraintValid(pVal->u.horusStr, pErrCode);
            break;          
        case horusInt_PRESENT : 
            ret = horusCustomFieldValues_horusInt_IsConstraintValid((&(pVal->u.horusInt)), pErrCode);
            break;          
        case horusReal_PRESENT : 
            ret = horusCustomFieldValues_horusReal_IsConstraintValid((&(pVal->u.horusReal)), pErrCode);
            break;          
        case horusBool_PRESENT : 
            ret = horusBitFlags_IsConstraintValid((&(pVal->u.horusBool)), pErrCode);
            break;          
        default: /*COVERAGE_IGNORE*/
    	    *pErrCode = ERR_CUSTOMFIELDVALUES;      /*COVERAGE_IGNORE*/
    	    ret = FALSE;                               /*COVERAGE_IGNORE*/
    }

	return ret;
}

void horusCustomFieldValues_horusStr_Initialize(horusCustomFieldValues_horusStr pVal)
{
	(void)pVal;


	memset(pVal, ' ', 255);
	pVal[255] = 0;

}
void horusCustomFieldValues_horusInt_Initialize(horusCustomFieldValues_horusInt* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 4) {
	    pVal->arr[i1] = 0LL;
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void horusCustomFieldValues_horusReal_Initialize(horusCustomFieldValues_horusReal* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 4) {
	    pVal->arr[i1] = 0.0000000000000000000E+000;
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void horusCustomFieldValues_Initialize(horusCustomFieldValues* pVal)
{
	(void)pVal;


	pVal->kind = horusStr_PRESENT;
	horusCustomFieldValues_horusStr_Initialize(pVal->u.horusStr);
}

flag horusCustomFieldValues_Encode(const horusCustomFieldValues* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	asn1SccSint nStringLength;
	*pErrCode = 0;
	ret = bCheckConstraints ? horusCustomFieldValues_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind)
	    {
	    case horusStr_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	nStringLength = strlen(pVal->u.horusStr);
	    	/*ret = nStringLength >= 0 && nStringLength <= 255;*/
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, nStringLength, 0, 255);
	    	for(i1=0; (i1 < (int)nStringLength) && ret; i1++)
	    	{
	    		static byte allowedCharSet[] = {0x20,0x2B,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,
	    		                                0x35,0x36,0x37,0x38,0x39,0x3D,0x41,0x42,0x43,0x44,
	    		                                0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,
	    		                                0x4F,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,
	    		                                0x59,0x5A,0x5F,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
	    		                                0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,
	    		                                0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A};
	    		int charIndex = GetCharIndex(pVal->u.horusStr[i1], allowedCharSet, 69);
	    		BitStream_EncodeConstraintWholeNumber(pBitStrm, charIndex, 0, 68);
	    	}

	    	break;
	    case horusInt_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->u.horusInt.nCount, 1, 4);
	    	for(i1=0; (i1 < (int)pVal->u.horusInt.nCount) && ret; i1++)
	    	{
	    		BitStream_EncodeUnConstraintWholeNumber(pBitStrm, pVal->u.horusInt.arr[i1]);
	    	}
	    	break;
	    case horusReal_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->u.horusReal.nCount, 1, 4);
	    	for(i1=0; (i1 < (int)pVal->u.horusReal.nCount) && ret; i1++)
	    	{
	    		BitStream_EncodeReal(pBitStrm, pVal->u.horusReal.arr[i1]);
	    	}
	    	break;
	    case horusBool_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = horusBitFlags_Encode((&(pVal->u.horusBool)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_CUSTOMFIELDVALUES;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag horusCustomFieldValues_Decode(horusCustomFieldValues* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint horusCustomFieldValues_index_tmp;
	int i1;
	asn1SccSint nStringLength;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &horusCustomFieldValues_index_tmp, 0, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_CUSTOMFIELDVALUES;
	if (ret) {
	    switch(horusCustomFieldValues_index_tmp)
	    {
	    case 0:
	    	pVal->kind = horusStr_PRESENT;
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nStringLength, 0, 255);
	    	for(i1=0; (i1 < (int)nStringLength) && ret; i1++)
	    	{
	    		static byte allowedCharSet[] = {0x20,0x2B,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,
	    		                                0x35,0x36,0x37,0x38,0x39,0x3D,0x41,0x42,0x43,0x44,
	    		                                0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,
	    		                                0x4F,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,
	    		                                0x59,0x5A,0x5F,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
	    		                                0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,
	    		                                0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A};
	    		asn1SccSint charIndex = 0;
	    		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charIndex, 0, 68);
	    		*pErrCode = ret ? 0 : ERR_UPER_DECODE_CUSTOMFIELDVALUES_HORUSSTR;
	    		pVal->u.horusStr[i1] = ret ? allowedCharSet[charIndex] : '\0' ;
	    	}
	    	pVal->u.horusStr[nStringLength] = 0x0;
	    	break;
	    case 1:
	    	pVal->kind = horusInt_PRESENT;
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_CUSTOMFIELDVALUES_HORUSINT;
	    	pVal->u.horusInt.nCount = (long)nCount;
	    	for(i1=0; (i1 < (int)pVal->u.horusInt.nCount) && ret; i1++)
	    	{
	    		ret = BitStream_DecodeUnConstraintWholeNumber(pBitStrm, (&(pVal->u.horusInt.arr[i1])));   
	    		*pErrCode = ret ? 0 : ERR_UPER_DECODE_CUSTOMFIELDVALUES_HORUSINT_ELM;                               
	    	}
	    	break;
	    case 2:
	    	pVal->kind = horusReal_PRESENT;
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_CUSTOMFIELDVALUES_HORUSREAL;
	    	pVal->u.horusReal.nCount = (long)nCount;
	    	for(i1=0; (i1 < (int)pVal->u.horusReal.nCount) && ret; i1++)
	    	{
	    		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->u.horusReal.arr[i1])));
	    		*pErrCode = ret ? 0 : ERR_UPER_DECODE_CUSTOMFIELDVALUES_HORUSREAL_ELM;
	    	}
	    	break;
	    case 3:
	    	pVal->kind = horusBool_PRESENT;
	    	ret = horusBitFlags_Decode((&(pVal->u.horusBool)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_CUSTOMFIELDVALUES;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && horusCustomFieldValues_IsConstraintValid(pVal, pErrCode);
}


flag AdditionalSensorType_name_CharsAreValid_0(const char* str)
{
    flag ret=TRUE;
    int i=0;

    while ((str[i] != '\0') && ret) {
        ret = ret && (strchr("abcdefghijklmnopqrstuvwxyz0123456789-", str[i]));
        i = i + 1;
    }
    return ret;
}
flag horusAdditionalSensorType_name_IsConstraintValid(const horusAdditionalSensorType_name pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (AdditionalSensorType_name_CharsAreValid_0(pVal) && ((1 <= strlen(pVal)) && (strlen(pVal) <= 20)));
    *pErrCode = ret ? 0 :  ERR_ADDITIONALSENSORTYPE_NAME;

	return ret;
}

flag horusAdditionalSensorType_IsConstraintValid(const horusAdditionalSensorType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.name) {
    	ret = horusAdditionalSensorType_name_IsConstraintValid(pVal->name, pErrCode);
    }
    if (ret) {
        if (pVal->exist.values) {
        	ret = horusCustomFieldValues_IsConstraintValid((&(pVal->values)), pErrCode);
        }
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void horusAdditionalSensorType_name_Initialize(horusAdditionalSensorType_name pVal)
{
	(void)pVal;


	memset(pVal, '-', 20);
	pVal[20] = 0;

}
void horusAdditionalSensorType_Initialize(horusAdditionalSensorType* pVal)
{
	(void)pVal;


	/*set name */
	pVal->exist.name = 1;
	horusAdditionalSensorType_name_Initialize(pVal->name);
	/*set values */
	pVal->exist.values = 1;
	horusCustomFieldValues_Initialize((&(pVal->values)));
}

flag horusAdditionalSensorType_Encode(const horusAdditionalSensorType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	asn1SccSint nStringLength;
	*pErrCode = 0;
	ret = bCheckConstraints ? horusAdditionalSensorType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.name);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.values);
	        if (ret) {
	            /*Encode name */
	            if (pVal->exist.name) {
	            	nStringLength = strlen(pVal->name);
	            	/*ret = nStringLength >= 1 && nStringLength <= 20;*/
	            	BitStream_EncodeConstraintWholeNumber(pBitStrm, nStringLength, 1, 20);
	            	for(i1=0; (i1 < (int)nStringLength) && ret; i1++)
	            	{
	            		static byte allowedCharSet[] = {0x2D,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,
	            		                                0x39,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
	            		                                0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,0x73,
	            		                                0x74,0x75,0x76,0x77,0x78,0x79,0x7A};
	            		int charIndex = GetCharIndex(pVal->name[i1], allowedCharSet, 37);
	            		BitStream_EncodeConstraintWholeNumber(pBitStrm, charIndex, 0, 36);
	            	}

	            }
	            if (ret) {
	                /*Encode values */
	                if (pVal->exist.values) {
	                	ret = horusCustomFieldValues_Encode((&(pVal->values)), pBitStrm, pErrCode, FALSE);
	                }
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag horusAdditionalSensorType_Decode(horusAdditionalSensorType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;
	int i1;
	asn1SccSint nStringLength;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.name = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ADDITIONALSENSORTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.values = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_ADDITIONALSENSORTYPE;
	    if (ret) {
	        /*Decode name */
	        if (pVal->exist.name) {
	        	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nStringLength, 1, 20);
	        	for(i1=0; (i1 < (int)nStringLength) && ret; i1++)
	        	{
	        		static byte allowedCharSet[] = {0x2D,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,
	        		                                0x39,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
	        		                                0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,0x73,
	        		                                0x74,0x75,0x76,0x77,0x78,0x79,0x7A};
	        		asn1SccSint charIndex = 0;
	        		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charIndex, 0, 36);
	        		*pErrCode = ret ? 0 : ERR_UPER_DECODE_ADDITIONALSENSORTYPE_NAME;
	        		pVal->name[i1] = ret ? allowedCharSet[charIndex] : '\0' ;
	        	}
	        	pVal->name[nStringLength] = 0x0;
	        }
	        if (ret) {
	            /*Decode values */
	            if (pVal->exist.values) {
	            	ret = horusCustomFieldValues_Decode((&(pVal->values)), pBitStrm, pErrCode);
	            }
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && horusAdditionalSensorType_IsConstraintValid(pVal, pErrCode);
}


flag horusAdditionalSensors_IsConstraintValid(const horusAdditionalSensors* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_ADDITIONALSENSORS;
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
        {
        	ret = horusAdditionalSensorType_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void horusAdditionalSensors_Initialize(horusAdditionalSensors* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 4) {
	    horusAdditionalSensorType_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag horusAdditionalSensors_Encode(const horusAdditionalSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? horusAdditionalSensors_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
	    {
	    	ret = horusAdditionalSensorType_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag horusAdditionalSensors_Decode(horusAdditionalSensors* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ADDITIONALSENSORS;
	pVal->nCount = (long)nCount;
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
	{
		ret = horusAdditionalSensorType_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && horusAdditionalSensors_IsConstraintValid(pVal, pErrCode);
}


flag horusTemperatureSensors_internal_IsConstraintValid(const horusTemperatureSensors_internal* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1023 <= (*(pVal))) && ((*(pVal)) <= 1023));
    *pErrCode = ret ? 0 :  ERR_TEMPERATURESENSORS_INTERNAL;

	return ret;
}

flag horusTemperatureSensors_external_IsConstraintValid(const horusTemperatureSensors_external* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1023 <= (*(pVal))) && ((*(pVal)) <= 1023));
    *pErrCode = ret ? 0 :  ERR_TEMPERATURESENSORS_EXTERNAL;

	return ret;
}

flag horusTemperatureSensors_custom1_IsConstraintValid(const horusTemperatureSensors_custom1* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1023 <= (*(pVal))) && ((*(pVal)) <= 1023));
    *pErrCode = ret ? 0 :  ERR_TEMPERATURESENSORS_CUSTOM1;

	return ret;
}

flag horusTemperatureSensors_custom2_IsConstraintValid(const horusTemperatureSensors_custom2* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1023 <= (*(pVal))) && ((*(pVal)) <= 1023));
    *pErrCode = ret ? 0 :  ERR_TEMPERATURESENSORS_CUSTOM2;

	return ret;
}

flag horusTemperatureSensors_IsConstraintValid(const horusTemperatureSensors* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.internal) {
    	ret = horusTemperatureSensors_internal_IsConstraintValid((&(pVal->internal)), pErrCode);
    }
    if (ret) {
        if (pVal->exist.external) {
        	ret = horusTemperatureSensors_external_IsConstraintValid((&(pVal->external)), pErrCode);
        }
        if (ret) {
            if (pVal->exist.custom1) {
            	ret = horusTemperatureSensors_custom1_IsConstraintValid((&(pVal->custom1)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.custom2) {
                	ret = horusTemperatureSensors_custom2_IsConstraintValid((&(pVal->custom2)), pErrCode);
                }
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void horusTemperatureSensors_internal_Initialize(horusTemperatureSensors_internal* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void horusTemperatureSensors_external_Initialize(horusTemperatureSensors_external* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void horusTemperatureSensors_custom1_Initialize(horusTemperatureSensors_custom1* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void horusTemperatureSensors_custom2_Initialize(horusTemperatureSensors_custom2* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void horusTemperatureSensors_Initialize(horusTemperatureSensors* pVal)
{
	(void)pVal;


	/*set internal */
	pVal->exist.internal = 1;
	horusTemperatureSensors_internal_Initialize((&(pVal->internal)));
	/*set external */
	pVal->exist.external = 1;
	horusTemperatureSensors_external_Initialize((&(pVal->external)));
	/*set custom1 */
	pVal->exist.custom1 = 1;
	horusTemperatureSensors_custom1_Initialize((&(pVal->custom1)));
	/*set custom2 */
	pVal->exist.custom2 = 1;
	horusTemperatureSensors_custom2_Initialize((&(pVal->custom2)));
}

flag horusTemperatureSensors_Encode(const horusTemperatureSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? horusTemperatureSensors_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.internal);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.external);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.custom1);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.custom2);
	                if (ret) {
	                    /*Encode internal */
	                    if (pVal->exist.internal) {
	                    	BitStream_EncodeConstraintWholeNumber(pBitStrm, (asn1SccSint)(pVal->internal), -1023, 1023);
	                    }
	                    if (ret) {
	                        /*Encode external */
	                        if (pVal->exist.external) {
	                        	BitStream_EncodeConstraintWholeNumber(pBitStrm, (asn1SccSint)(pVal->external), -1023, 1023);
	                        }
	                        if (ret) {
	                            /*Encode custom1 */
	                            if (pVal->exist.custom1) {
	                            	BitStream_EncodeConstraintWholeNumber(pBitStrm, (asn1SccSint)(pVal->custom1), -1023, 1023);
	                            }
	                            if (ret) {
	                                /*Encode custom2 */
	                                if (pVal->exist.custom2) {
	                                	BitStream_EncodeConstraintWholeNumber(pBitStrm, (asn1SccSint)(pVal->custom2), -1023, 1023);
	                                }
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag horusTemperatureSensors_Decode(horusTemperatureSensors* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.internal = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TEMPERATURESENSORS;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.external = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TEMPERATURESENSORS;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.custom1 = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_TEMPERATURESENSORS;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.custom2 = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_TEMPERATURESENSORS;
	            if (ret) {
	                /*Decode internal */
	                if (pVal->exist.internal) {
	                	ret = BitStream_DecodeConstraintWholeNumberInt16(pBitStrm, (&(pVal->internal)), -1023, 1023);
	                	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TEMPERATURESENSORS_INTERNAL;
	                }
	                if (ret) {
	                    /*Decode external */
	                    if (pVal->exist.external) {
	                    	ret = BitStream_DecodeConstraintWholeNumberInt16(pBitStrm, (&(pVal->external)), -1023, 1023);
	                    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TEMPERATURESENSORS_EXTERNAL;
	                    }
	                    if (ret) {
	                        /*Decode custom1 */
	                        if (pVal->exist.custom1) {
	                        	ret = BitStream_DecodeConstraintWholeNumberInt16(pBitStrm, (&(pVal->custom1)), -1023, 1023);
	                        	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TEMPERATURESENSORS_CUSTOM1;
	                        }
	                        if (ret) {
	                            /*Decode custom2 */
	                            if (pVal->exist.custom2) {
	                            	ret = BitStream_DecodeConstraintWholeNumberInt16(pBitStrm, (&(pVal->custom2)), -1023, 1023);
	                            	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TEMPERATURESENSORS_CUSTOM2;
	                            }
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && horusTemperatureSensors_IsConstraintValid(pVal, pErrCode);
}


flag horusMilliVoltSensors_battery_IsConstraintValid(const horusMilliVoltSensors_battery* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 16383UL);
    *pErrCode = ret ? 0 :  ERR_MILLIVOLTSENSORS_BATTERY;

	return ret;
}

flag horusMilliVoltSensors_solar_IsConstraintValid(const horusMilliVoltSensors_solar* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 16383UL);
    *pErrCode = ret ? 0 :  ERR_MILLIVOLTSENSORS_SOLAR;

	return ret;
}

flag horusMilliVoltSensors_custom1_IsConstraintValid(const horusMilliVoltSensors_custom1* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 16383UL);
    *pErrCode = ret ? 0 :  ERR_MILLIVOLTSENSORS_CUSTOM1;

	return ret;
}

flag horusMilliVoltSensors_custom2_IsConstraintValid(const horusMilliVoltSensors_custom2* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 16383UL);
    *pErrCode = ret ? 0 :  ERR_MILLIVOLTSENSORS_CUSTOM2;

	return ret;
}

flag horusMilliVoltSensors_IsConstraintValid(const horusMilliVoltSensors* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.battery) {
    	ret = horusMilliVoltSensors_battery_IsConstraintValid((&(pVal->battery)), pErrCode);
    }
    if (ret) {
        if (pVal->exist.solar) {
        	ret = horusMilliVoltSensors_solar_IsConstraintValid((&(pVal->solar)), pErrCode);
        }
        if (ret) {
            if (pVal->exist.custom1) {
            	ret = horusMilliVoltSensors_custom1_IsConstraintValid((&(pVal->custom1)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.custom2) {
                	ret = horusMilliVoltSensors_custom2_IsConstraintValid((&(pVal->custom2)), pErrCode);
                }
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void horusMilliVoltSensors_battery_Initialize(horusMilliVoltSensors_battery* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void horusMilliVoltSensors_solar_Initialize(horusMilliVoltSensors_solar* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void horusMilliVoltSensors_custom1_Initialize(horusMilliVoltSensors_custom1* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void horusMilliVoltSensors_custom2_Initialize(horusMilliVoltSensors_custom2* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void horusMilliVoltSensors_Initialize(horusMilliVoltSensors* pVal)
{
	(void)pVal;


	/*set battery */
	pVal->exist.battery = 1;
	horusMilliVoltSensors_battery_Initialize((&(pVal->battery)));
	/*set solar */
	pVal->exist.solar = 1;
	horusMilliVoltSensors_solar_Initialize((&(pVal->solar)));
	/*set custom1 */
	pVal->exist.custom1 = 1;
	horusMilliVoltSensors_custom1_Initialize((&(pVal->custom1)));
	/*set custom2 */
	pVal->exist.custom2 = 1;
	horusMilliVoltSensors_custom2_Initialize((&(pVal->custom2)));
}

flag horusMilliVoltSensors_Encode(const horusMilliVoltSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? horusMilliVoltSensors_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.battery);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.solar);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.custom1);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.custom2);
	                if (ret) {
	                    /*Encode battery */
	                    if (pVal->exist.battery) {
	                    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->battery), 0, 16383);
	                    }
	                    if (ret) {
	                        /*Encode solar */
	                        if (pVal->exist.solar) {
	                        	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->solar), 0, 16383);
	                        }
	                        if (ret) {
	                            /*Encode custom1 */
	                            if (pVal->exist.custom1) {
	                            	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->custom1), 0, 16383);
	                            }
	                            if (ret) {
	                                /*Encode custom2 */
	                                if (pVal->exist.custom2) {
	                                	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->custom2), 0, 16383);
	                                }
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag horusMilliVoltSensors_Decode(horusMilliVoltSensors* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.battery = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MILLIVOLTSENSORS;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.solar = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_MILLIVOLTSENSORS;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.custom1 = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_MILLIVOLTSENSORS;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.custom2 = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_MILLIVOLTSENSORS;
	            if (ret) {
	                /*Decode battery */
	                if (pVal->exist.battery) {
	                	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->battery)), 0, 16383);
	                	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MILLIVOLTSENSORS_BATTERY;
	                }
	                if (ret) {
	                    /*Decode solar */
	                    if (pVal->exist.solar) {
	                    	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->solar)), 0, 16383);
	                    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MILLIVOLTSENSORS_SOLAR;
	                    }
	                    if (ret) {
	                        /*Decode custom1 */
	                        if (pVal->exist.custom1) {
	                        	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->custom1)), 0, 16383);
	                        	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MILLIVOLTSENSORS_CUSTOM1;
	                        }
	                        if (ret) {
	                            /*Decode custom2 */
	                            if (pVal->exist.custom2) {
	                            	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->custom2)), 0, 16383);
	                            	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MILLIVOLTSENSORS_CUSTOM2;
	                            }
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && horusMilliVoltSensors_IsConstraintValid(pVal, pErrCode);
}


flag horusGnssPowerSaveState_IsConstraintValid(const horusGnssPowerSaveState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((*(pVal)) == horuspsmNotActive)) || (((*(pVal)) == horusenabled)))) || (((*(pVal)) == horusacquisition)))) || (((*(pVal)) == horustracking)))) || (((*(pVal)) == horusoptimised)))) || (((*(pVal)) == horusinactive)));
    *pErrCode = ret ? 0 :  ERR_GNSSPOWERSAVESTATE;

	return ret;
}

void horusGnssPowerSaveState_Initialize(horusGnssPowerSaveState* pVal)
{
	(void)pVal;


	(*(pVal)) = horuspsmNotActive;
}

flag horusGnssPowerSaveState_Encode(const horusGnssPowerSaveState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? horusGnssPowerSaveState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case horuspsmNotActive:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case horusenabled:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case horusacquisition:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case horustracking:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case horusoptimised:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case horusinactive:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_GNSSPOWERSAVESTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag horusGnssPowerSaveState_Decode(horusGnssPowerSaveState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_GNSSPOWERSAVESTATE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = horuspsmNotActive;
	                break;
	            case 1:
	                (*(pVal)) = horusenabled;
	                break;
	            case 2:
	                (*(pVal)) = horusacquisition;
	                break;
	            case 3:
	                (*(pVal)) = horustracking;
	                break;
	            case 4:
	                (*(pVal)) = horusoptimised;
	                break;
	            case 5:
	                (*(pVal)) = horusinactive;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_GNSSPOWERSAVESTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = horuspsmNotActive;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && horusGnssPowerSaveState_IsConstraintValid(pVal, pErrCode);
}


flag Telemetry_payloadCallsign_CharsAreValid_0(const char* str)
{
    flag ret=TRUE;
    int i=0;

    while ((str[i] != '\0') && ret) {
        ret = ret && (strchr("-/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", str[i]));
        i = i + 1;
    }
    return ret;
}
flag horusTelemetry_payloadCallsign_IsConstraintValid(const horusTelemetry_payloadCallsign pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (Telemetry_payloadCallsign_CharsAreValid_0(pVal) && ((1 <= strlen(pVal)) && (strlen(pVal) <= 15)));
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_PAYLOADCALLSIGN;

	return ret;
}

flag horusTelemetry_sequenceNumber_IsConstraintValid(const horusTelemetry_sequenceNumber* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag horusTelemetry_timeOfDaySeconds_IsConstraintValid(const horusTelemetry_timeOfDaySeconds* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1 <= (*(pVal))) && ((*(pVal)) <= 86400));
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_TIMEOFDAYSECONDS;

	return ret;
}

flag horusTelemetry_latitude_IsConstraintValid(const horusTelemetry_latitude* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-9000000 <= (*(pVal))) && ((*(pVal)) <= 9000000));
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_LATITUDE;

	return ret;
}

flag horusTelemetry_longitude_IsConstraintValid(const horusTelemetry_longitude* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-18000000 <= (*(pVal))) && ((*(pVal)) <= 18000000));
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_LONGITUDE;

	return ret;
}

flag horusTelemetry_altitudeMeters_IsConstraintValid(const horusTelemetry_altitudeMeters* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1000 <= (*(pVal))) && ((*(pVal)) <= 50000));
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_ALTITUDEMETERS;

	return ret;
}

flag horusTelemetry_velocityHorizontalKilometersPerHour_IsConstraintValid(const horusTelemetry_velocityHorizontalKilometersPerHour* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 512UL);
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_VELOCITYHORIZONTALKILOMETERSPERHOUR;

	return ret;
}

flag horusTelemetry_gnssSatellitesVisible_IsConstraintValid(const horusTelemetry_gnssSatellitesVisible* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 31UL);
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_GNSSSATELLITESVISIBLE;

	return ret;
}

flag horusTelemetry_ascentRateCentimetersPerSecond_IsConstraintValid(const horusTelemetry_ascentRateCentimetersPerSecond* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (-32767 <= (*(pVal)));
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_ASCENTRATECENTIMETERSPERSECOND;

	return ret;
}

flag horusTelemetry_pressurehPa_x10_IsConstraintValid(const horusTelemetry_pressurehPa_x10* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 12000UL);
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_PRESSUREHPA_X10;

	return ret;
}

flag horusTelemetry_humidityPercentage_IsConstraintValid(const horusTelemetry_humidityPercentage* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 100UL);
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_HUMIDITYPERCENTAGE;

	return ret;
}

flag horusTelemetry_counts_IsConstraintValid(const horusTelemetry_counts* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 8));
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_COUNTS;

	return ret;
}

flag horusTelemetry_customData_IsConstraintValid(const horusTelemetry_customData* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->nCount <= 255);
    *pErrCode = ret ? 0 :  ERR_TELEMETRY_CUSTOMDATA;

	return ret;
}

flag horusTelemetry_IsConstraintValid(const horusTelemetry* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = horusTelemetry_payloadCallsign_IsConstraintValid(pVal->payloadCallsign, pErrCode);
    if (ret) {
        ret = horusTelemetry_sequenceNumber_IsConstraintValid((&(pVal->sequenceNumber)), pErrCode);
        if (ret) {
            ret = horusTelemetry_timeOfDaySeconds_IsConstraintValid((&(pVal->timeOfDaySeconds)), pErrCode);
            if (ret) {
                ret = horusTelemetry_latitude_IsConstraintValid((&(pVal->latitude)), pErrCode);
                if (ret) {
                    ret = horusTelemetry_longitude_IsConstraintValid((&(pVal->longitude)), pErrCode);
                    if (ret) {
                        ret = horusTelemetry_altitudeMeters_IsConstraintValid((&(pVal->altitudeMeters)), pErrCode);
                        if (ret) {
                            if (pVal->exist.extraSensors) {
                            	ret = horusAdditionalSensors_IsConstraintValid((&(pVal->extraSensors)), pErrCode);
                            }
                            if (ret) {
                                if (pVal->exist.velocityHorizontalKilometersPerHour) {
                                	ret = horusTelemetry_velocityHorizontalKilometersPerHour_IsConstraintValid((&(pVal->velocityHorizontalKilometersPerHour)), pErrCode);
                                }
                                if (ret) {
                                    if (pVal->exist.gnssSatellitesVisible) {
                                    	ret = horusTelemetry_gnssSatellitesVisible_IsConstraintValid((&(pVal->gnssSatellitesVisible)), pErrCode);
                                    }
                                    if (ret) {
                                        if (pVal->exist.ascentRateCentimetersPerSecond) {
                                        	ret = horusTelemetry_ascentRateCentimetersPerSecond_IsConstraintValid((&(pVal->ascentRateCentimetersPerSecond)), pErrCode);
                                        }
                                        if (ret) {
                                            if (pVal->exist.pressurehPa_x10) {
                                            	ret = horusTelemetry_pressurehPa_x10_IsConstraintValid((&(pVal->pressurehPa_x10)), pErrCode);
                                            }
                                            if (ret) {
                                                if (pVal->exist.temperatureCelsius_x10) {
                                                	ret = horusTemperatureSensors_IsConstraintValid((&(pVal->temperatureCelsius_x10)), pErrCode);
                                                }
                                                if (ret) {
                                                    if (pVal->exist.humidityPercentage) {
                                                    	ret = horusTelemetry_humidityPercentage_IsConstraintValid((&(pVal->humidityPercentage)), pErrCode);
                                                    }
                                                    if (ret) {
                                                        if (pVal->exist.milliVolts) {
                                                        	ret = horusMilliVoltSensors_IsConstraintValid((&(pVal->milliVolts)), pErrCode);
                                                        }
                                                        if (ret) {
                                                            if (pVal->exist.counts) {
                                                            	ret = horusTelemetry_counts_IsConstraintValid((&(pVal->counts)), pErrCode);
                                                            }
                                                            if (ret) {
                                                                if (pVal->exist.gnssPowerSaveState) {
                                                                	ret = horusGnssPowerSaveState_IsConstraintValid((&(pVal->gnssPowerSaveState)), pErrCode);
                                                                }
                                                                if (ret) {
                                                                    if (pVal->exist.customData) {
                                                                    	ret = horusTelemetry_customData_IsConstraintValid((&(pVal->customData)), pErrCode);
                                                                    }
                                                                }   /*COVERAGE_IGNORE*/
                                                            }   /*COVERAGE_IGNORE*/
                                                        }   /*COVERAGE_IGNORE*/
                                                    }   /*COVERAGE_IGNORE*/
                                                }   /*COVERAGE_IGNORE*/
                                            }   /*COVERAGE_IGNORE*/
                                        }   /*COVERAGE_IGNORE*/
                                    }   /*COVERAGE_IGNORE*/
                                }   /*COVERAGE_IGNORE*/
                            }   /*COVERAGE_IGNORE*/
                        }   /*COVERAGE_IGNORE*/
                    }   /*COVERAGE_IGNORE*/
                }   /*COVERAGE_IGNORE*/
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void horusTelemetry_payloadCallsign_Initialize(horusTelemetry_payloadCallsign pVal)
{
	(void)pVal;


	memset(pVal, '-', 15);
	pVal[15] = 0;

}
void horusTelemetry_sequenceNumber_Initialize(horusTelemetry_sequenceNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void horusTelemetry_timeOfDaySeconds_Initialize(horusTelemetry_timeOfDaySeconds* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void horusTelemetry_latitude_Initialize(horusTelemetry_latitude* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void horusTelemetry_longitude_Initialize(horusTelemetry_longitude* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void horusTelemetry_altitudeMeters_Initialize(horusTelemetry_altitudeMeters* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void horusTelemetry_velocityHorizontalKilometersPerHour_Initialize(horusTelemetry_velocityHorizontalKilometersPerHour* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void horusTelemetry_gnssSatellitesVisible_Initialize(horusTelemetry_gnssSatellitesVisible* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void horusTelemetry_ascentRateCentimetersPerSecond_Initialize(horusTelemetry_ascentRateCentimetersPerSecond* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void horusTelemetry_pressurehPa_x10_Initialize(horusTelemetry_pressurehPa_x10* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void horusTelemetry_humidityPercentage_Initialize(horusTelemetry_humidityPercentage* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void horusTelemetry_counts_Initialize(horusTelemetry_counts* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 8) {
	    pVal->arr[i1] = 0LL;
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void horusTelemetry_customData_Initialize(horusTelemetry_customData* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 255);
	pVal->nCount = 0;

}
void horusTelemetry_Initialize(horusTelemetry* pVal)
{
	(void)pVal;


	/*set extensionMarkerForASN1CC */
	pVal->exist.extensionMarkerForASN1CC = 1;
	pVal->extensionMarkerForASN1CC = FALSE;
	/*set payloadCallsign */
	horusTelemetry_payloadCallsign_Initialize(pVal->payloadCallsign);
	/*set sequenceNumber */
	horusTelemetry_sequenceNumber_Initialize((&(pVal->sequenceNumber)));
	/*set timeOfDaySeconds */
	horusTelemetry_timeOfDaySeconds_Initialize((&(pVal->timeOfDaySeconds)));
	/*set latitude */
	horusTelemetry_latitude_Initialize((&(pVal->latitude)));
	/*set longitude */
	horusTelemetry_longitude_Initialize((&(pVal->longitude)));
	/*set altitudeMeters */
	horusTelemetry_altitudeMeters_Initialize((&(pVal->altitudeMeters)));
	/*set extraSensors */
	pVal->exist.extraSensors = 1;
	horusAdditionalSensors_Initialize((&(pVal->extraSensors)));
	/*set velocityHorizontalKilometersPerHour */
	pVal->exist.velocityHorizontalKilometersPerHour = 1;
	horusTelemetry_velocityHorizontalKilometersPerHour_Initialize((&(pVal->velocityHorizontalKilometersPerHour)));
	/*set gnssSatellitesVisible */
	pVal->exist.gnssSatellitesVisible = 1;
	horusTelemetry_gnssSatellitesVisible_Initialize((&(pVal->gnssSatellitesVisible)));
	/*set ascentRateCentimetersPerSecond */
	pVal->exist.ascentRateCentimetersPerSecond = 1;
	horusTelemetry_ascentRateCentimetersPerSecond_Initialize((&(pVal->ascentRateCentimetersPerSecond)));
	/*set pressurehPa_x10 */
	pVal->exist.pressurehPa_x10 = 1;
	horusTelemetry_pressurehPa_x10_Initialize((&(pVal->pressurehPa_x10)));
	/*set temperatureCelsius_x10 */
	pVal->exist.temperatureCelsius_x10 = 1;
	horusTemperatureSensors_Initialize((&(pVal->temperatureCelsius_x10)));
	/*set humidityPercentage */
	pVal->exist.humidityPercentage = 1;
	horusTelemetry_humidityPercentage_Initialize((&(pVal->humidityPercentage)));
	/*set milliVolts */
	pVal->exist.milliVolts = 1;
	horusMilliVoltSensors_Initialize((&(pVal->milliVolts)));
	/*set counts */
	pVal->exist.counts = 1;
	horusTelemetry_counts_Initialize((&(pVal->counts)));
	/*set gnssPowerSaveState */
	pVal->exist.gnssPowerSaveState = 1;
	horusGnssPowerSaveState_Initialize((&(pVal->gnssPowerSaveState)));
	/*set customData */
	pVal->exist.customData = 1;
	horusTelemetry_customData_Initialize((&(pVal->customData)));
}

flag horusTelemetry_Encode(const horusTelemetry* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	asn1SccSint nStringLength;
	*pErrCode = 0;
	ret = bCheckConstraints ? horusTelemetry_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.extensionMarkerForASN1CC);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.extraSensors);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.velocityHorizontalKilometersPerHour);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.gnssSatellitesVisible);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.ascentRateCentimetersPerSecond);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.pressurehPa_x10);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.temperatureCelsius_x10);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.humidityPercentage);
	                                if (ret) {
	                                    BitStream_AppendBit(pBitStrm,pVal->exist.milliVolts);
	                                    if (ret) {
	                                        BitStream_AppendBit(pBitStrm,pVal->exist.counts);
	                                        if (ret) {
	                                            BitStream_AppendBit(pBitStrm,pVal->exist.gnssPowerSaveState);
	                                            if (ret) {
	                                                BitStream_AppendBit(pBitStrm,pVal->exist.customData);
	                                                if (ret) {
	                                                    /*Encode extensionMarkerForASN1CC */
	                                                    if (pVal->exist.extensionMarkerForASN1CC) {
	                                                    	BitStream_AppendBit(pBitStrm,pVal->extensionMarkerForASN1CC);
	                                                    }
	                                                    if (ret) {
	                                                        /*Encode payloadCallsign */
	                                                        nStringLength = strlen(pVal->payloadCallsign);
	                                                        /*ret = nStringLength >= 1 && nStringLength <= 15;*/
	                                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, nStringLength, 1, 15);
	                                                        for(i1=0; (i1 < (int)nStringLength) && ret; i1++)
	                                                        {
	                                                        	static byte allowedCharSet[] = {0x2D,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
	                                                        	                                0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,
	                                                        	                                0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x52,
	                                                        	                                0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x61,0x62,
	                                                        	                                0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,
	                                                        	                                0x6D,0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,
	                                                        	                                0x77,0x78,0x79,0x7A};
	                                                        	int charIndex = GetCharIndex(pVal->payloadCallsign[i1], allowedCharSet, 64);
	                                                        	BitStream_EncodeConstraintWholeNumber(pBitStrm, charIndex, 0, 63);
	                                                        }

	                                                        if (ret) {
	                                                            /*Encode sequenceNumber */
	                                                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->sequenceNumber), 0, 65535);
	                                                            if (ret) {
	                                                                /*Encode timeOfDaySeconds */
	                                                                BitStream_EncodeConstraintWholeNumber(pBitStrm, (asn1SccSint)(pVal->timeOfDaySeconds), -1, 86400);
	                                                                if (ret) {
	                                                                    /*Encode latitude */
	                                                                    BitStream_EncodeConstraintWholeNumber(pBitStrm, (asn1SccSint)(pVal->latitude), -9000000, 9000000);
	                                                                    if (ret) {
	                                                                        /*Encode longitude */
	                                                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, (asn1SccSint)(pVal->longitude), -18000000, 18000000);
	                                                                        if (ret) {
	                                                                            /*Encode altitudeMeters */
	                                                                            BitStream_EncodeConstraintWholeNumber(pBitStrm, (asn1SccSint)(pVal->altitudeMeters), -1000, 50000);
	                                                                            if (ret) {
	                                                                                /*Encode extraSensors */
	                                                                                if (pVal->exist.extraSensors) {
	                                                                                	ret = horusAdditionalSensors_Encode((&(pVal->extraSensors)), pBitStrm, pErrCode, FALSE);
	                                                                                }
	                                                                                if (ret) {
	                                                                                    /*Encode velocityHorizontalKilometersPerHour */
	                                                                                    if (pVal->exist.velocityHorizontalKilometersPerHour) {
	                                                                                    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->velocityHorizontalKilometersPerHour), 0, 512);
	                                                                                    }
	                                                                                    if (ret) {
	                                                                                        /*Encode gnssSatellitesVisible */
	                                                                                        if (pVal->exist.gnssSatellitesVisible) {
	                                                                                        	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->gnssSatellitesVisible), 0, 31);
	                                                                                        }
	                                                                                        if (ret) {
	                                                                                            /*Encode ascentRateCentimetersPerSecond */
	                                                                                            if (pVal->exist.ascentRateCentimetersPerSecond) {
	                                                                                            	BitStream_EncodeConstraintWholeNumber(pBitStrm, (asn1SccSint)(pVal->ascentRateCentimetersPerSecond), -32767, 32767);
	                                                                                            }
	                                                                                            if (ret) {
	                                                                                                /*Encode pressurehPa_x10 */
	                                                                                                if (pVal->exist.pressurehPa_x10) {
	                                                                                                	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->pressurehPa_x10), 0, 12000);
	                                                                                                }
	                                                                                                if (ret) {
	                                                                                                    /*Encode temperatureCelsius_x10 */
	                                                                                                    if (pVal->exist.temperatureCelsius_x10) {
	                                                                                                    	ret = horusTemperatureSensors_Encode((&(pVal->temperatureCelsius_x10)), pBitStrm, pErrCode, FALSE);
	                                                                                                    }
	                                                                                                    if (ret) {
	                                                                                                        /*Encode humidityPercentage */
	                                                                                                        if (pVal->exist.humidityPercentage) {
	                                                                                                        	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->humidityPercentage), 0, 100);
	                                                                                                        }
	                                                                                                        if (ret) {
	                                                                                                            /*Encode milliVolts */
	                                                                                                            if (pVal->exist.milliVolts) {
	                                                                                                            	ret = horusMilliVoltSensors_Encode((&(pVal->milliVolts)), pBitStrm, pErrCode, FALSE);
	                                                                                                            }
	                                                                                                            if (ret) {
	                                                                                                                /*Encode counts */
	                                                                                                                if (pVal->exist.counts) {
	                                                                                                                	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->counts.nCount, 1, 8);
	                                                                                                                	for(i1=0; (i1 < (int)pVal->counts.nCount) && ret; i1++)
	                                                                                                                	{
	                                                                                                                		BitStream_EncodeUnConstraintWholeNumber(pBitStrm, pVal->counts.arr[i1]);
	                                                                                                                	}
	                                                                                                                }
	                                                                                                                if (ret) {
	                                                                                                                    /*Encode gnssPowerSaveState */
	                                                                                                                    if (pVal->exist.gnssPowerSaveState) {
	                                                                                                                    	ret = horusGnssPowerSaveState_Encode((&(pVal->gnssPowerSaveState)), pBitStrm, pErrCode, FALSE);
	                                                                                                                    }
	                                                                                                                    if (ret) {
	                                                                                                                        /*Encode customData */
	                                                                                                                        if (pVal->exist.customData) {
	                                                                                                                        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->customData.nCount, 0, 255);
	                                                                                                                        	ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->customData.arr, pVal->customData.nCount);
	                                                                                                                        }
	                                                                                                                    }   /*COVERAGE_IGNORE*/
	                                                                                                                }   /*COVERAGE_IGNORE*/
	                                                                                                            }   /*COVERAGE_IGNORE*/
	                                                                                                        }   /*COVERAGE_IGNORE*/
	                                                                                                    }   /*COVERAGE_IGNORE*/
	                                                                                                }   /*COVERAGE_IGNORE*/
	                                                                                            }   /*COVERAGE_IGNORE*/
	                                                                                        }   /*COVERAGE_IGNORE*/
	                                                                                    }   /*COVERAGE_IGNORE*/
	                                                                                }   /*COVERAGE_IGNORE*/
	                                                                            }   /*COVERAGE_IGNORE*/
	                                                                        }   /*COVERAGE_IGNORE*/
	                                                                    }   /*COVERAGE_IGNORE*/
	                                                                }   /*COVERAGE_IGNORE*/
	                                                            }   /*COVERAGE_IGNORE*/
	                                                        }   /*COVERAGE_IGNORE*/
	                                                    }   /*COVERAGE_IGNORE*/
	                                                }   /*COVERAGE_IGNORE*/
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag horusTelemetry_Decode(horusTelemetry* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;
	int i1;
	asn1SccSint nStringLength;
	asn1SccSint nCount;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.extensionMarkerForASN1CC = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.extraSensors = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.velocityHorizontalKilometersPerHour = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.gnssSatellitesVisible = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.ascentRateCentimetersPerSecond = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.pressurehPa_x10 = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.temperatureCelsius_x10 = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.humidityPercentage = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	                            if (ret) {
	                                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                pVal->exist.milliVolts = presenceBit == 0 ? 0 : 1;
	                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	                                if (ret) {
	                                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                    pVal->exist.counts = presenceBit == 0 ? 0 : 1;
	                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	                                    if (ret) {
	                                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                        pVal->exist.gnssPowerSaveState = presenceBit == 0 ? 0 : 1;
	                                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	                                        if (ret) {
	                                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                            pVal->exist.customData = presenceBit == 0 ? 0 : 1;
	                                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY;
	                                            if (ret) {
	                                                /*Decode extensionMarkerForASN1CC */
	                                                if (pVal->exist.extensionMarkerForASN1CC) {
	                                                	ret = BitStream_ReadBit(pBitStrm, (&(pVal->extensionMarkerForASN1CC)));
	                                                	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_EXTENSIONMARKERFORASN1CC;
	                                                }
	                                                if (ret) {
	                                                    /*Decode payloadCallsign */
	                                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nStringLength, 1, 15);
	                                                    for(i1=0; (i1 < (int)nStringLength) && ret; i1++)
	                                                    {
	                                                    	static byte allowedCharSet[] = {0x2D,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
	                                                    	                                0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,
	                                                    	                                0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x52,
	                                                    	                                0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x61,0x62,
	                                                    	                                0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,
	                                                    	                                0x6D,0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,
	                                                    	                                0x77,0x78,0x79,0x7A};
	                                                    	asn1SccSint charIndex = 0;
	                                                    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charIndex, 0, 63);
	                                                    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_PAYLOADCALLSIGN;
	                                                    	pVal->payloadCallsign[i1] = ret ? allowedCharSet[charIndex] : '\0' ;
	                                                    }
	                                                    pVal->payloadCallsign[nStringLength] = 0x0;
	                                                    if (ret) {
	                                                        /*Decode sequenceNumber */
	                                                        ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->sequenceNumber)), 0, 65535);
	                                                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_SEQUENCENUMBER;
	                                                        if (ret) {
	                                                            /*Decode timeOfDaySeconds */
	                                                            ret = BitStream_DecodeConstraintWholeNumberInt32(pBitStrm, (&(pVal->timeOfDaySeconds)), -1, 86400);
	                                                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_TIMEOFDAYSECONDS;
	                                                            if (ret) {
	                                                                /*Decode latitude */
	                                                                ret = BitStream_DecodeConstraintWholeNumberInt32(pBitStrm, (&(pVal->latitude)), -9000000, 9000000);
	                                                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_LATITUDE;
	                                                                if (ret) {
	                                                                    /*Decode longitude */
	                                                                    ret = BitStream_DecodeConstraintWholeNumberInt32(pBitStrm, (&(pVal->longitude)), -18000000, 18000000);
	                                                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_LONGITUDE;
	                                                                    if (ret) {
	                                                                        /*Decode altitudeMeters */
	                                                                        ret = BitStream_DecodeConstraintWholeNumberInt32(pBitStrm, (&(pVal->altitudeMeters)), -1000, 50000);
	                                                                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_ALTITUDEMETERS;
	                                                                        if (ret) {
	                                                                            /*Decode extraSensors */
	                                                                            if (pVal->exist.extraSensors) {
	                                                                            	ret = horusAdditionalSensors_Decode((&(pVal->extraSensors)), pBitStrm, pErrCode);
	                                                                            }
	                                                                            if (ret) {
	                                                                                /*Decode velocityHorizontalKilometersPerHour */
	                                                                                if (pVal->exist.velocityHorizontalKilometersPerHour) {
	                                                                                	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->velocityHorizontalKilometersPerHour)), 0, 512);
	                                                                                	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_VELOCITYHORIZONTALKILOMETERSPERHOUR;
	                                                                                }
	                                                                                if (ret) {
	                                                                                    /*Decode gnssSatellitesVisible */
	                                                                                    if (pVal->exist.gnssSatellitesVisible) {
	                                                                                    	ret = BitStream_DecodeConstraintPosWholeNumberUInt8(pBitStrm, (&(pVal->gnssSatellitesVisible)), 0, 31);
	                                                                                    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_GNSSSATELLITESVISIBLE;
	                                                                                    }
	                                                                                    if (ret) {
	                                                                                        /*Decode ascentRateCentimetersPerSecond */
	                                                                                        if (pVal->exist.ascentRateCentimetersPerSecond) {
	                                                                                        	ret = BitStream_DecodeConstraintWholeNumberInt16(pBitStrm, (&(pVal->ascentRateCentimetersPerSecond)), -32767, 32767);
	                                                                                        	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_ASCENTRATECENTIMETERSPERSECOND;
	                                                                                        }
	                                                                                        if (ret) {
	                                                                                            /*Decode pressurehPa_x10 */
	                                                                                            if (pVal->exist.pressurehPa_x10) {
	                                                                                            	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->pressurehPa_x10)), 0, 12000);
	                                                                                            	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_PRESSUREHPA_X10;
	                                                                                            }
	                                                                                            if (ret) {
	                                                                                                /*Decode temperatureCelsius_x10 */
	                                                                                                if (pVal->exist.temperatureCelsius_x10) {
	                                                                                                	ret = horusTemperatureSensors_Decode((&(pVal->temperatureCelsius_x10)), pBitStrm, pErrCode);
	                                                                                                }
	                                                                                                if (ret) {
	                                                                                                    /*Decode humidityPercentage */
	                                                                                                    if (pVal->exist.humidityPercentage) {
	                                                                                                    	ret = BitStream_DecodeConstraintPosWholeNumberUInt8(pBitStrm, (&(pVal->humidityPercentage)), 0, 100);
	                                                                                                    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_HUMIDITYPERCENTAGE;
	                                                                                                    }
	                                                                                                    if (ret) {
	                                                                                                        /*Decode milliVolts */
	                                                                                                        if (pVal->exist.milliVolts) {
	                                                                                                        	ret = horusMilliVoltSensors_Decode((&(pVal->milliVolts)), pBitStrm, pErrCode);
	                                                                                                        }
	                                                                                                        if (ret) {
	                                                                                                            /*Decode counts */
	                                                                                                            if (pVal->exist.counts) {
	                                                                                                            	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 8);
	                                                                                                            	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_COUNTS;
	                                                                                                            	pVal->counts.nCount = (long)nCount;
	                                                                                                            	for(i1=0; (i1 < (int)pVal->counts.nCount) && ret; i1++)
	                                                                                                            	{
	                                                                                                            		ret = BitStream_DecodeUnConstraintWholeNumber(pBitStrm, (&(pVal->counts.arr[i1])));   
	                                                                                                            		*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_COUNTS_ELM;                               
	                                                                                                            	}
	                                                                                                            }
	                                                                                                            if (ret) {
	                                                                                                                /*Decode gnssPowerSaveState */
	                                                                                                                if (pVal->exist.gnssPowerSaveState) {
	                                                                                                                	ret = horusGnssPowerSaveState_Decode((&(pVal->gnssPowerSaveState)), pBitStrm, pErrCode);
	                                                                                                                }
	                                                                                                                if (ret) {
	                                                                                                                    /*Decode customData */
	                                                                                                                    if (pVal->exist.customData) {
	                                                                                                                    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 255);
	                                                                                                                    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TELEMETRY_CUSTOMDATA;
	                                                                                                                    	pVal->customData.nCount = (long)nCount;
	                                                                                                                    	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->customData.arr, pVal->customData.nCount);
	                                                                                                                    }
	                                                                                                                }   /*COVERAGE_IGNORE*/
	                                                                                                            }   /*COVERAGE_IGNORE*/
	                                                                                                        }   /*COVERAGE_IGNORE*/
	                                                                                                    }   /*COVERAGE_IGNORE*/
	                                                                                                }   /*COVERAGE_IGNORE*/
	                                                                                            }   /*COVERAGE_IGNORE*/
	                                                                                        }   /*COVERAGE_IGNORE*/
	                                                                                    }   /*COVERAGE_IGNORE*/
	                                                                                }   /*COVERAGE_IGNORE*/
	                                                                            }   /*COVERAGE_IGNORE*/
	                                                                        }   /*COVERAGE_IGNORE*/
	                                                                    }   /*COVERAGE_IGNORE*/
	                                                                }   /*COVERAGE_IGNORE*/
	                                                            }   /*COVERAGE_IGNORE*/
	                                                        }   /*COVERAGE_IGNORE*/
	                                                    }   /*COVERAGE_IGNORE*/
	                                                }   /*COVERAGE_IGNORE*/
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && horusTelemetry_IsConstraintValid(pVal, pErrCode);
}


